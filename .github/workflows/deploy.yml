name: Deploy to Cloud Run

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual triggers

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  SERVICE_NAME: psx-research-agent
  REGION: asia-southeast1
  IMAGE_NAME: asia-southeast1-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/psx-research-agent/psx-research-agent

jobs:
  deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write  # Required for Workload Identity Federation

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: github-actions-deployer@${{ secrets.GCP_PROJECT_ID }}.iam.gserviceaccount.com

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev --quiet

      - name: Build Docker image
        run: |
          docker build -t $IMAGE_NAME:$GITHUB_SHA -t $IMAGE_NAME:latest .

      - name: Push Docker image
        run: |
          docker push $IMAGE_NAME:$GITHUB_SHA
          docker push $IMAGE_NAME:latest

      - name: Deploy to Cloud Run
        run: |
          gcloud run deploy $SERVICE_NAME \
            --image $IMAGE_NAME:$GITHUB_SHA \
            --platform managed \
            --region $REGION \
            --allow-unauthenticated \
            --set-env-vars OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY }} \
            --memory 2Gi \
            --cpu 2 \
            --timeout 3600 \
            --max-instances 1 \
            --min-instances 0 \
            --port 8080 \
            --cpu-boost \
            --startup-probe="httpGet.path=/health,httpGet.port=8080,initialDelaySeconds=10,timeoutSeconds=10,periodSeconds=10,failureThreshold=30"

      - name: Clean up old images
        if: success()
        run: |
          # Keep only the latest 1 image (newest by creation time)
          # This ensures we stay within the 500MB free tier limit
          echo "Checking for old images to clean up..."
          
          # Get all unique images by digest, sorted by creation time (newest first)
          # Using a custom format that combines package and version with @ separator
          gcloud artifacts docker images list \
            $IMAGE_NAME \
            --format="csv[no-heading](package,version)" \
            --sort-by=~create_time > /tmp/all_images.txt 2>/dev/null || touch /tmp/all_images.txt
          
          # Convert CSV format (package,version) to image@digest format
          sed 's/,/@/' /tmp/all_images.txt > /tmp/images_formatted.txt 2>/dev/null || touch /tmp/images_formatted.txt
          
          IMAGE_COUNT=$(wc -l < /tmp/images_formatted.txt | tr -d ' ')
          
          if [ "$IMAGE_COUNT" -eq 0 ]; then
            echo "No images found (first deployment or cleanup already completed)"
            rm -f /tmp/all_images.txt /tmp/images_formatted.txt
            exit 0
          fi
          
          echo "Total unique images: $IMAGE_COUNT"
          echo "Images found:"
          cat /tmp/images_formatted.txt | head -5
          if [ "$IMAGE_COUNT" -gt 5 ]; then
            echo "... and $((IMAGE_COUNT - 5)) more"
          fi
          
          # Store the image we want to keep (newest)
          KEEP_IMAGE=$(head -1 /tmp/images_formatted.txt)
          echo ""
          echo "Keeping newest image: $KEEP_IMAGE"
          
          # If we have more than 1 image, delete the old ones (keep first 1 = newest)
          if [ "$IMAGE_COUNT" -gt 1 ]; then
            DELETE_COUNT=$((IMAGE_COUNT - 1))
            echo "Deleting $DELETE_COUNT old image(s) (keeping 1 newest)..."
            
            DELETED=0
            FAILED=0
            
            # Read lines starting from line 2 (skip first 1 newest image)
            # Use process substitution to avoid subshell issues with variables
            while IFS= read -r image_ref; do
              if [ -n "$image_ref" ]; then
                echo "Deleting old image: $image_ref"
                # Try deletion with retry (up to 2 retries)
                RETRY_COUNT=0
                MAX_RETRIES=2
                DELETED_SUCCESS=false
                
                while [ $RETRY_COUNT -le $MAX_RETRIES ]; do
                  if gcloud artifacts docker images delete "$image_ref" --delete-tags --quiet 2>/dev/null; then
                    DELETED_SUCCESS=true
                    break
                  fi
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                  if [ $RETRY_COUNT -le $MAX_RETRIES ]; then
                    echo "  Retrying deletion (attempt $((RETRY_COUNT + 1))/$((MAX_RETRIES + 1)))..."
                    sleep 2
                  fi
                done
                
                if [ "$DELETED_SUCCESS" = true ]; then
                  echo "  ✅ Deleted successfully"
                  DELETED=$((DELETED + 1))
                else
                  echo "  ⚠️  Warning: Failed to delete after $((MAX_RETRIES + 1)) attempts (may already be deleted or in use)"
                  FAILED=$((FAILED + 1))
                fi
              fi
            done < <(tail -n +2 /tmp/images_formatted.txt)
            
            echo ""
            echo "Cleanup summary:"
            echo "  Successfully deleted: $DELETED"
            echo "  Failed/Skipped: $FAILED"
            
            # Verify the kept image still exists
            echo ""
            echo "Verifying kept image still exists..."
            if gcloud artifacts docker images describe "$KEEP_IMAGE" --quiet >/dev/null 2>&1; then
              echo "✅ Kept image verified: $KEEP_IMAGE"
            else
              echo "⚠️  Warning: Kept image not found! This should not happen."
              echo "   Image reference: $KEEP_IMAGE"
            fi
            
            echo ""
            echo "✅ Cleanup complete. Kept 1 most recent image."
          else
            echo "✅ No cleanup needed. Only $IMAGE_COUNT image(s) stored."
          fi
          
          rm -f /tmp/all_images.txt /tmp/images_formatted.txt

